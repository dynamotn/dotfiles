# /etc/syslog-ng/syslog-ng.conf

@version: 3.22
@module system-source

options {
  # IP addresses are more reliable descriptors and doesn't require a network
  # connection for consistent logging
  use_dns(no);
  dns_cache(no);

  # Output log stats every 12 hours, and include details about individual
  # connections and log files.
  stats_freq(43200);
  stats_level(1);

  # Use a more standard timestamp, but keep the precision requested for
  # RFC5424 TIME-SECFRAC
  ts_format(iso);
  frac_digits(6);
};

source local {
  system();
  internal();
};

template t_raw_message {
  template('${MESSAGE}\n');
};


### Network Server & Client Logging

# NOTE: There are two network sources, syslog() and network(). network()
# handles RFC3164 and RFC5424 syslog message formats with or without framing.
# syslog() appears to only accept framed messages in RFC5424. syslog() defaults
# to port 601/tcp, network() default to port 514/tcp.
#
# NOTE: By specifying IPv6 the port will bind to both protocols instead of just
# IPv4
#
#source networkSrc {
#  network(ip-protocol(6) transport(tcp));
#  network(ip-protocol(6) transport(udp));
#
#  # Optional TLS mechanism for receiving logs encrypted and/or authenticated
#  #network(
#  #  ip-protocol(6)
#  #  port(6514)
#  #  transport(tls)
#  #
#  #  tls(
#  #    cert-file(/etc/syslog-ng/server.crt)
#  #    key-file(/etc/syslog-ng/server.key)
#  #
#  #    # Directory containing certificates in the PEM format that are
#  #    # considered trusted signers for authentication.
#  #    ca-dir(/etc/syslog-ng/ca.d)
#  #
#  #    # A custom suite of accepted ciphers, this is based on the version of
#  #    # openssl used by syslog-ng.
#  #    #cipher-suite('ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384')
#  #
#  #    # Other use parameters...
#  #    #dhparam-file(...)
#  #    #ecdh-curve-list('prime256v1:secp384r1')
#  #
#  #    # Disable mutual authentication, but if the client presents a
#  #    # certificate ensure its valid. Default is 'required-trusted'
#  #    #peer-verify(optional-trusted)
#  #  )
#  #);
#};
#destination networkLogs { file(/var/log/network/$HOST/system.log create-dirs(yes)); };
#log { source(networkSrc); destination(networkLogs); };

# NOTE: Due to the 'final' flags later on in the config, any network based
# senders need to be configured before the local destinations.
#
#destination centralLogServer {
#  network('10.64.0.120'
#    ip-protocol(6)
#    port(514)
#    transport(tcp)
#
#    # TODO: Transport could be switched to TLS by adjusting the transport(),
#    # and matching the tls() configs in the sample network server above. This
#    # requires a certificate authority and distribution of client certificates.
#
#    # Ensure any reload/restarts on server or client, or ephemeral network
#    # issues do not cause us to lose messages.
#    disk-buffer(
#      mem-buf-size(10000)
#      disk-buf-size(2000000)
#      reliable(yes)
#    )
#  );
#};
#log { source(local); destination(centralLogServer); };


### Handle the auditd syslog events to dedicated files, and prevent them from
### going anywhere else.

destination auditFile { file(/var/log/audit.log template(t_raw_message)); };
destination avcFile { file(/var/log/avc.log template(t_raw_message));   };
filter auditLogs { level(info) and facility(local6) and program(audispd); };

# NOTE: I don't believe AVC messages are getting grabbed by this...

log {
  source(local);

  filter(auditLogs);

  if (message('type=AVC')) {
    destination(avcFile);
  } else {
    destination(auditFile);
  };

  flags(final);
};


### General logging configuration that matches the standard RHEL rsyslog
### config.

destination messageFile { file(/var/log/messages); };
filter messages { level(info) and not (facility(mail, authpriv, cron)); };
log { source(local); filter(messages); destination(messageFile); };

destination secureFile { file(/var/log/secure); };
filter authpriv { facility(authpriv); };
log { source(local); filter(authpriv); destination(secureFile); };

destination mailFile { file(/var/log/maillog); };
filter mail { facility(mail); };
log { source(local); filter(mail); destination(mailFile); flags(final); };

destination cronFile { file(/var/log/cron); };
filter cron { facility(cron); };
log { source(local); filter(cron); destination(cronFile); };

destination spoolFile { file(/var/log/spooler); };
filter spool { facility(uucp) or (facility(news) and level(crit)); };
log { source(local); filter(spool); destination(spoolFile); };

destination bootFile { file(/var/log/boot.log); };
filter boot { facility(local7); };
log { source(local); filter(boot); destination(bootFile); };


### Send all system emergency messages to all users

destination allUsers { usertty('*'); };
filter emergency { level(emerg) and not (facility(mail)); };
log { source(local); filter(emergency); destination(allUsers); };


### Diagnostic Logging

# I can't help but think there are some important logs being missed... This
# diagnostic coding can allow me to track down missing logs locally when I need
# to find those and where they're coming from. Worth noting that
#
#template t_diagnostic {
#  template('f:${FACILITY}/l:${LEVEL}/s:${SOURCE}/prog:${PROGRAM}/pid:${PID} - ${ISODATE} ${HOST} ${MSGHDR}${MESSAGE}\n');
#};
#destination allLogs { file(/var/log/all template(t_diagnostic)); };
#log { source(local); destination(allLogs); };
